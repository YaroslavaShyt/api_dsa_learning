# INSERT INTO lesson_plan_step (NUMBER, NAME) VALUES
# (1, 'Визначення алгоритму'),
# (2, 'Властивості алгоритму'),
# (3, 'Оцінка складності алгоритму'),
# (4, 'Асимптотична оцінка');

# INSERT INTO lesson_plan (step1_id, step2_id, step3_id, step4_id) VALUES
# (5, 6, 7, 8);

# INSERT INTO theory_step (theory_text, theory_image, plan_id, plan_step_id)
# VALUES('У повсякденному житті люди постійно користуються алгоритмами, навіть не задумуючись над цим.
# Це різноманітні правила, інструкції, рецепти тощо. Наприклад, щоб заварити чай, ми кип’ятимо воду, в чашку насипаємо
# заварку, заливаємо її кип’ятком, настоюємо 5 хвилин. Хоч можна спочатку в чашку насипати заварки, а потім починати
# кип’ятити воду — але так буде довше. Отже, послідовність дій має значення.
# Алгоритм — точний набір інструкцій (правил, процедур, команд), які описують порядок дій певного виконавця для
# розв’язання певної задачі чи певного класу задач за скінченну кількість кроків.
# Аналіз ефективності алгоритму полягає в оцінці часової складності (ще кажуть: трудомісткості, обчислювальної складності)
#  — часових витрат на його виконання, і ємнісної складності (ще кажуть: просторової складності) — обсягу використовуваної
#   оперативної пам’яті залежно від обсягу вхідних даних. Фактично, оцінка часової складності алгоритму зводиться до
#   кількості основних операцій, які виконуються в алгоритмі. При цьому різні операції потребують різного часу виконання
#   і тому часто оцінюють складність алгоритмів щодо певних операцій (наприклад, порівнянь, перестановок, проходів циклу
#   тощо).
# ', '', 2, 5),
# ('Характерними властивостями алгоритмів є такі:
# 1) дискретність (роздільність, переривчастість) — алгоритм складається з окремих кроків (послідовності закінчених дій) і
# перехід до наступного кроку можливий лише після закінчення виконання попереднього;
# 2) визначеність (однозначність) — кожен алгоритм будують з врахуванням певного виконавця — наприклад, комп’ютера,
# програміста чи звичайного користувача.
# 3) результативність (скінченність) — виконання алгоритму має приводити до одержання конкретного результату
# (цей результат може бути й негативним: задача не має розв’язку, алгоритм не можна застосувати тощо) при будь-яких
# вхідних даних за скінченну кількість кроків (і не просто скінченну, а досить обмежену, розумну кількість кроків);
# 4) масовість — за допомогою алгоритму можна розв’язувати не одну конкретну задачу, а багато однотипних задач певного
# класу і робити це неодноразово, що дає можливість збільшити практичну цінність алгоритму.
# ', '', 2, 6),
# ('Складність алгоритмів оцінюють за часом виконання або за обсягом використовуваної пам’яті. У більшості
# випадків складність залежить від обсягу вхідних даних. Так, масив з 10 елементів буде оброблятися швидше, ніж із 10000.
# При цьому точний час залежить від процесора, типу даних, мови програмування та інших параметрів.
# Для оцінки складності алгоритмів використовують таке поняття, як асимптотична складність, і його пов’язують з обробкою
# дуже великих наборів даних. Нехай n — кількість елементів вхідних даних, функція f(n) описує верхню межу максимальної
# кількості основних операцій (додавання, множення, порівняння, присвоювання, перестановок тощо), які виконуються в
# алгоритмі.
# Якщо функція f(n) зростає не швидше, ніж деякий багаточлен (поліном) P(n), то кажуть, що алгоритм має поліноміальну
# складність, або алгоритм є поліноміальним, інакше алгоритм є неполіноміальним. Поліноміальні алгоритми для великих
# обсягів даних, характерних для практичних задач, можуть виконуватися на сучасних комп’ютерах, а неполіноміальні
# (це, як правило, алгоритми повного перебору) через великі потреби часу не можуть виконатися повністю.
#
# ', '', 2, 7),
# ('Оскільки в більшості випадків точний вигляд функції f(n) записати складно, то використовують її
# асимптотичну оцінку O(g(n)). Наприклад:
# O(1) — константна складність алгоритму (сталий час виконання алгоритму) не залежить від обсягу вхідних даних
# (наприклад, при вибіркових обстеженнях успішності студентів треба одержати інформацію про студентів з номерами 5, 12, 28.
# Одиниця у формулі не означає, що алгоритм виконується за одну операцію або потребує дуже мало часу — він може
# виконуватися і мілісекунду, і день, і рік чи навіть більше.
# O(n) — лінійна складність (наприклад, пошук максимального елемента в масиві; додавання чи віднімання двох n-розрядних
# чисел); подвоєння обсягу даних збільшує вдвічі час обробки.
# Аналогічно до часової складності можна оцінювати ємнісну складність алгоритмів. При цьому може бути, що зі збільшенням
# обсягу даних потрібний обсяг пам’яті значно збільшується, але алгоритм виконується швидко або навпаки — обсяг пам’яті
# збільшується несуттєво, але час виконання значно збільшується. Тому при виборі конкретного алгоритму треба враховувати
# вимоги й умови щодо його використання. Наприклад, алгоритм, який виконується вдесятеро швидше, але використовує
# вдесятеро більше пам’яті може працювати з великою кількістю даних на серверному комп’ютері з великим обсягом пам’яті,
# але на звичайних комп’ютерах з невеликим обсягом пам’яті він виконуватися не буде.
#
# ', '', 2, 8);


# INSERT INTO theory (step1_id, step2_id, step3_id, step4_id) VALUES (13, 14, 15, 16);


# INSERT INTO answers (answer)
# VALUES ('Набір інструкцій для виконання конкретної задачі'),
#        ('Збірка комп’ютерних програм'),
#        ('Метод обчислення чисел'),
#        ('Пояснення розв\'язку задачі'),
#        ('Масовість'),
#        ('Дискретність'),
#        ('Визначеність'),
#        ('Результативність'),
#        ('Лінійна складність'),
#        ('Асимптотична складність'),
#        ('Константна складність'),
#        ('Поліноміальна складність'),
#        ('Час виконання алгоритму не залежить від розміру вхідних даних'),
#        ('Пошук максимального елемента в масиві'),
#        ('Пошук елемента в бінарному дереві'),
#        ('Сортування масиву методом бульбашки'),
#        ('Підрахунок кількості елементів у списку');

# INSERT INTO answer_variants (correct_answer_id, first_answer_id, second_answer_id, third_answer_id, fourth_answer_id)
# VALUES (5, 1, 2, 3, 4),
#        (12, 6, 7, 8, 9),
#        (14, 13, 15, 16, 17),
#        (18, 20, 19, 21, 13);


# INSERT INTO game_task (questionNumber, question, answers, question_number, task_answers_type) VALUES
# (1, 'Що таке алгоритм?', 2, 1, 1),
# (2,
#  'Яка з наступних властивостей алгоритму означає, що виконання алгоритму призводить
# до одержання конкретного результату за скінченну кількість кроків?', 3, 2, 1),
# (3,
#  'Як називається оцінка складності алгоритму, яка пов''язана з обробкою великих наборів даних і визначає,
# як функція f(n) зростає при збільшенні кількості елементів?', 4, 3, 1),
# (4,
#  'Що з наведеного є прикладом алгоритму з лінійною складністю O(n)?',
#  5, 4, 1)
# ;

# INSERT INTO game (name, time_limit) VALUES ('Перевірка знань: Поняття алгоритму', 360);
# INSERT INTO game_task_to_game (game_id, game_task_id) VALUES
# (3, 2),
# (3, 3),
# (3, 4),
# (3, 5);

# LESSON PLAN 2
# TITLE: Урок 1: Поняття алгоритму

INSERT INTO lesson (game_id, topic_id, theory_id, lesson_plan_id) VALUES
(3, 2, 3, 2);